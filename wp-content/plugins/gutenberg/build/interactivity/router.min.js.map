{"version":3,"file":"./build/interactivity/router.min.js","mappings":"2CACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,8BCElF,MAAM,GAFEI,EAE+B,CAAE,gBAAqB,IAAMC,EAA8DC,gBAAiB,sBAA2B,IAAMD,EAA8DE,sBAAuB,OAAY,IAAMF,EAA8DG,OAAQ,MAAW,IAAMH,EAA8DI,MAAO,OAAY,IAAMJ,EAA8DK,QAFpfC,EAAI,CAAC,EAAGrB,EAAoBsB,EAAED,EAAGP,GAAWO,GCYzDE,EAAQ,IAAIC,IAIZC,EAAaC,IAClB,MAAMC,EAAI,IAAIC,IAAKF,EAAKG,OAAOC,UAC/B,OAAOH,EAAEI,SAAWJ,EAAEK,MAAM,EAoBvBC,EAAkBC,IACvB,MAAMC,EAAU,CAAC,EACXC,EAAY,QAAQpB,EAAAA,gCAC1BkB,EAAIG,iBAAmB,IAAID,MAAeE,SAAWC,IACpD,MAAMC,EAAKD,EAAOE,aAAcL,GAChCD,EAASK,IAAOpB,EAAAA,EAAAA,QAAQmB,EAAQ,IAEjC,MAAMG,EAAQR,EAAIS,cAAe,UAAWC,UAC5C,MAAO,CAAET,UAASO,QAAO,EAIpBG,EAAkBC,IACvB,MAAMV,EAAY,QAAQpB,EAAAA,gCAC1B+B,SAASV,iBAAmB,IAAID,MAAeE,SAAWC,IACzD,MAAMC,EAAKD,EAAOE,aAAcL,GAC1BY,GAAW/B,EAAAA,EAAAA,uBAAuBsB,IACxCrB,EAAAA,EAAAA,QAAQ4B,EAAKX,QAASK,GAAMQ,EAAU,IAElCF,EAAKJ,QACTK,SAASL,MAAQI,EAAKJ,MACvB,ED3DO5B,MAAWO,EC+DnB,IAAI4B,EAAe,GAInBpB,OAAOqB,iBAAkB,YAAYC,UACpC,MAAMzB,EAAMD,EAAUI,OAAOC,UACvBgB,EAAOvB,EAAM6B,IAAK1B,UAAiBH,EAAMf,IAAKkB,GAC/CoB,EACJD,EAAeC,GAEfjB,OAAOC,SAASuB,QACjB,IAID9B,EAAM+B,IACL7B,EAAUI,OAAOC,UACjByB,QAAQC,QAASvB,EAAec,YAG1B,MAAM,MAAEU,EAAK,QAAEC,IAAYvC,EAAAA,EAAAA,OAAO,cAAe,CACvDuC,QAAS,CAwBR,SAACC,CAAUC,EAAMC,EAAU,CAAC,GAC3B,MAAMnC,EAAMD,EAAUmC,GACtBX,EAAeW,EACfF,EAAQI,SAAUpC,EAAKmC,GAIvB,MAAME,EAAiB,IAAIR,SAAWC,IAAO,aAC5CQ,WAAYR,EAAwB,QAAjB,EAAEK,EAAQI,eAAO,QAAI,IAAO,IAG1CnB,QAAaS,QAAQW,KAAM,CAChC3C,EAAMf,IAAKkB,GACXqC,IAMId,IAAiBW,IAEjBd,GACJD,EAAeC,GACfjB,OAAOsC,QACNN,EAAQO,QAAU,eAAiB,aACjC,CAAC,EAAG,GAAIR,KAEX/B,OAAOC,SAASuC,OAAQT,SAClB,IAAIL,SAAS,UAErB,EAcAO,QAAAA,CAAUpC,EAAKmC,EAAU,CAAC,GACzBnC,EAAMD,EAAUC,IACXmC,EAAQS,OAAW/C,EAAM6B,IAAK1B,IAClCH,EAAM+B,IAAK5B,EArIGyB,OAAQzB,GAAO6C,WAChC,IACC,IAAOA,EAAO,CACb,MAAMC,QAAY3C,OAAO4C,MAAO/C,GAChC,GAAoB,MAAf8C,EAAIE,OAAiB,OAAO,EACjCH,QAAaC,EAAIG,MAClB,CACA,MAAMzC,GAAM,IAAIL,OAAO+C,WAAYC,gBAAiBN,EAAM,aAC1D,OAAOtC,EAAeC,EACvB,CAAE,MAAQ4C,GACT,OAAO,CACR,GA0HmBC,CAAWrD,EAAKmC,GAElC,K","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/external module \"@wordpress/interactivity\"","webpack://wp/@wordpress/interactivity-router/src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"directivePrefix\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.directivePrefix, [\"getRegionRootFragment\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.getRegionRootFragment, [\"render\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.render, [\"store\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.store, [\"toVdom\"]: () => __WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__.toVdom });","/**\n * WordPress dependencies\n */\nimport {\n\trender,\n\tdirectivePrefix,\n\ttoVdom,\n\tgetRegionRootFragment,\n\tstore,\n} from '@wordpress/interactivity';\n\n// The cache of visited and prefetched pages.\nconst pages = new Map();\n\n// Helper to remove domain and hash from the URL. We are only interesting in\n// caching the path and the query.\nconst cleanUrl = ( url ) => {\n\tconst u = new URL( url, window.location );\n\treturn u.pathname + u.search;\n};\n\n// Fetch a new page and convert it to a static virtual DOM.\nconst fetchPage = async ( url, { html } ) => {\n\ttry {\n\t\tif ( ! html ) {\n\t\t\tconst res = await window.fetch( url );\n\t\t\tif ( res.status !== 200 ) return false;\n\t\t\thtml = await res.text();\n\t\t}\n\t\tconst dom = new window.DOMParser().parseFromString( html, 'text/html' );\n\t\treturn regionsToVdom( dom );\n\t} catch ( e ) {\n\t\treturn false;\n\t}\n};\n\n// Return an object with VDOM trees of those HTML regions marked with a\n// `router-region` directive.\nconst regionsToVdom = ( dom ) => {\n\tconst regions = {};\n\tconst attrName = `data-${ directivePrefix }-router-region`;\n\tdom.querySelectorAll( `[${ attrName }]` ).forEach( ( region ) => {\n\t\tconst id = region.getAttribute( attrName );\n\t\tregions[ id ] = toVdom( region );\n\t} );\n\tconst title = dom.querySelector( 'title' )?.innerText;\n\treturn { regions, title };\n};\n\n// Render all interactive regions contained in the given page.\nconst renderRegions = ( page ) => {\n\tconst attrName = `data-${ directivePrefix }-router-region`;\n\tdocument.querySelectorAll( `[${ attrName }]` ).forEach( ( region ) => {\n\t\tconst id = region.getAttribute( attrName );\n\t\tconst fragment = getRegionRootFragment( region );\n\t\trender( page.regions[ id ], fragment );\n\t} );\n\tif ( page.title ) {\n\t\tdocument.title = page.title;\n\t}\n};\n\n// Variable to store the current navigation.\nlet navigatingTo = '';\n\n// Listen to the back and forward buttons and restore the page if it's in the\n// cache.\nwindow.addEventListener( 'popstate', async () => {\n\tconst url = cleanUrl( window.location ); // Remove hash.\n\tconst page = pages.has( url ) && ( await pages.get( url ) );\n\tif ( page ) {\n\t\trenderRegions( page );\n\t} else {\n\t\twindow.location.reload();\n\t}\n} );\n\n// Cache the current regions.\npages.set(\n\tcleanUrl( window.location ),\n\tPromise.resolve( regionsToVdom( document ) )\n);\n\nexport const { state, actions } = store( 'core/router', {\n\tactions: {\n\t\t/**\n\t\t * Navigates to the specified page.\n\t\t *\n\t\t * This function normalizes the passed href, fetchs the page HTML if\n\t\t * needed, and updates any interactive regions whose contents have\n\t\t * changed. It also creates a new entry in the browser session history.\n\t\t *\n\t\t * @param {string}  href              The page href.\n\t\t * @param {Object}  [options]         Options object.\n\t\t * @param {boolean} [options.force]   If true, it forces re-fetching the\n\t\t *                                    URL.\n\t\t * @param {string}  [options.html]    HTML string to be used instead of\n\t\t *                                    fetching the requested URL.\n\t\t * @param {boolean} [options.replace] If true, it replaces the current\n\t\t *                                    entry in the browser session\n\t\t *                                    history.\n\t\t * @param {number}  [options.timeout] Time until the navigation is\n\t\t *                                    aborted, in milliseconds. Default\n\t\t *                                    is 10000.\n\t\t *\n\t\t * @return {Promise} Promise that resolves once the navigation is\n\t\t *                   completed or aborted.\n\t\t */\n\t\t*navigate( href, options = {} ) {\n\t\t\tconst url = cleanUrl( href );\n\t\t\tnavigatingTo = href;\n\t\t\tactions.prefetch( url, options );\n\n\t\t\t// Create a promise that resolves when the specified timeout ends.\n\t\t\t// The timeout value is 10 seconds by default.\n\t\t\tconst timeoutPromise = new Promise( ( resolve ) =>\n\t\t\t\tsetTimeout( resolve, options.timeout ?? 10000 )\n\t\t\t);\n\n\t\t\tconst page = yield Promise.race( [\n\t\t\t\tpages.get( url ),\n\t\t\t\ttimeoutPromise,\n\t\t\t] );\n\n\t\t\t// Once the page is fetched, the destination URL could have changed\n\t\t\t// (e.g., by clicking another link in the meantime). If so, bail\n\t\t\t// out, and let the newer execution to update the HTML.\n\t\t\tif ( navigatingTo !== href ) return;\n\n\t\t\tif ( page ) {\n\t\t\t\trenderRegions( page );\n\t\t\t\twindow.history[\n\t\t\t\t\toptions.replace ? 'replaceState' : 'pushState'\n\t\t\t\t]( {}, '', href );\n\t\t\t} else {\n\t\t\t\twindow.location.assign( href );\n\t\t\t\tyield new Promise( () => {} );\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Prefetchs the page with the passed URL.\n\t\t *\n\t\t * The function normalizes the URL and stores internally the fetch\n\t\t * promise, to avoid triggering a second fetch for an ongoing request.\n\t\t *\n\t\t * @param {string}  url             The page URL.\n\t\t * @param {Object}  [options]       Options object.\n\t\t * @param {boolean} [options.force] Force fetching the URL again.\n\t\t * @param {string}  [options.html]  HTML string to be used instead of\n\t\t *                                  fetching the requested URL.\n\t\t */\n\t\tprefetch( url, options = {} ) {\n\t\t\turl = cleanUrl( url );\n\t\t\tif ( options.force || ! pages.has( url ) ) {\n\t\t\t\tpages.set( url, fetchPage( url, options ) );\n\t\t\t}\n\t\t},\n\t},\n} );\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","y","__WEBPACK_EXTERNAL_MODULE__wordpress_interactivity_8e89b257__","directivePrefix","getRegionRootFragment","render","store","toVdom","x","d","pages","Map","cleanUrl","url","u","URL","window","location","pathname","search","regionsToVdom","dom","regions","attrName","querySelectorAll","forEach","region","id","getAttribute","title","querySelector","innerText","renderRegions","page","document","fragment","navigatingTo","addEventListener","async","has","reload","set","Promise","resolve","state","actions","navigate","href","options","prefetch","timeoutPromise","setTimeout","timeout","race","history","replace","assign","force","html","res","fetch","status","text","DOMParser","parseFromString","e","fetchPage"],"sourceRoot":""}