{"version":3,"file":"./build/upload-media/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/external window [\"wp\",\"data\"]","../../packages/upload-media/src/store/types.ts","../../packages/upload-media/src/store/reducer.ts","../../packages/upload-media/src/store/selectors.ts","../../packages/upload-media/src/store/private-selectors.ts","webpack://wp/./node_modules/uuid/dist/esm-browser/native.js","webpack://wp/./node_modules/uuid/dist/esm-browser/rng.js","webpack://wp/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://wp/./node_modules/uuid/dist/esm-browser/v4.js","webpack://wp/external window [\"wp\",\"i18n\"]","../../packages/upload-media/src/upload-error.ts","../../packages/upload-media/src/validate-mime-type.ts","../../packages/upload-media/src/validate-mime-type-for-user.ts","../../packages/upload-media/src/get-mime-types-array.ts","../../packages/upload-media/src/validate-file-size.ts","../../packages/upload-media/src/store/actions.ts","webpack://wp/external window [\"wp\",\"blob\"]","../../packages/upload-media/src/utils.ts","webpack://wp/external window [\"wp\",\"url\"]","../../packages/upload-media/src/stub-file.ts","../../packages/upload-media/src/store/private-actions.ts","webpack://wp/external window [\"wp\",\"privateApis\"]","../../packages/upload-media/src/lock-unlock.ts","../../packages/upload-media/src/store/constants.ts","../../packages/upload-media/src/store/index.ts","webpack://wp/external window [\"wp\",\"element\"]","webpack://wp/external window [\"wp\",\"compose\"]","webpack://wp/external window \"ReactJSXRuntime\"","../../packages/upload-media/src/components/provider/index.tsx","../../packages/upload-media/src/components/provider/with-registry-provider.tsx"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"data\"];","export type QueueItemId = string;\n\nexport type QueueStatus = 'active' | 'paused';\n\nexport type BatchId = string;\n\nexport interface QueueItem {\n\tid: QueueItemId;\n\tsourceFile: File;\n\tfile: File;\n\tposter?: File;\n\tattachment?: Partial< Attachment >;\n\tstatus: ItemStatus;\n\tadditionalData: AdditionalData;\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonError?: OnErrorHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tcurrentOperation?: OperationType;\n\toperations?: Operation[];\n\terror?: Error;\n\tbatchId?: string;\n\tsourceUrl?: string;\n\tsourceAttachmentId?: number;\n\tabortController?: AbortController;\n}\n\nexport interface State {\n\tqueue: QueueItem[];\n\tqueueStatus: QueueStatus;\n\tblobUrls: Record< QueueItemId, string[] >;\n\tsettings: Settings;\n}\n\nexport enum Type {\n\tUnknown = 'REDUX_UNKNOWN',\n\tAdd = 'ADD_ITEM',\n\tPrepare = 'PREPARE_ITEM',\n\tCancel = 'CANCEL_ITEM',\n\tRemove = 'REMOVE_ITEM',\n\tPauseItem = 'PAUSE_ITEM',\n\tResumeItem = 'RESUME_ITEM',\n\tPauseQueue = 'PAUSE_QUEUE',\n\tResumeQueue = 'RESUME_QUEUE',\n\tOperationStart = 'OPERATION_START',\n\tOperationFinish = 'OPERATION_FINISH',\n\tAddOperations = 'ADD_OPERATIONS',\n\tCacheBlobUrl = 'CACHE_BLOB_URL',\n\tRevokeBlobUrls = 'REVOKE_BLOB_URLS',\n\tUpdateSettings = 'UPDATE_SETTINGS',\n}\n\ntype Action< T = Type, Payload = Record< string, unknown > > = {\n\ttype: T;\n} & Payload;\n\nexport type UnknownAction = Action< Type.Unknown >;\nexport type AddAction = Action<\n\tType.Add,\n\t{\n\t\titem: Omit< QueueItem, 'operations' > &\n\t\t\tPartial< Pick< QueueItem, 'operations' > >;\n\t}\n>;\nexport type OperationStartAction = Action<\n\tType.OperationStart,\n\t{ id: QueueItemId; operation: OperationType }\n>;\nexport type OperationFinishAction = Action<\n\tType.OperationFinish,\n\t{\n\t\tid: QueueItemId;\n\t\titem: Partial< QueueItem >;\n\t}\n>;\nexport type AddOperationsAction = Action<\n\tType.AddOperations,\n\t{ id: QueueItemId; operations: Operation[] }\n>;\nexport type CancelAction = Action<\n\tType.Cancel,\n\t{ id: QueueItemId; error: Error }\n>;\nexport type PauseItemAction = Action< Type.PauseItem, { id: QueueItemId } >;\nexport type ResumeItemAction = Action< Type.ResumeItem, { id: QueueItemId } >;\nexport type PauseQueueAction = Action< Type.PauseQueue >;\nexport type ResumeQueueAction = Action< Type.ResumeQueue >;\nexport type RemoveAction = Action< Type.Remove, { id: QueueItemId } >;\nexport type CacheBlobUrlAction = Action<\n\tType.CacheBlobUrl,\n\t{ id: QueueItemId; blobUrl: string }\n>;\nexport type RevokeBlobUrlsAction = Action<\n\tType.RevokeBlobUrls,\n\t{ id: QueueItemId }\n>;\nexport type UpdateSettingsAction = Action<\n\tType.UpdateSettings,\n\t{ settings: Partial< Settings > }\n>;\n\ninterface UploadMediaArgs {\n\t// Additional data to include in the request.\n\tadditionalData?: AdditionalData;\n\t// Array with the types of media that can be uploaded, if unset all types are allowed.\n\tallowedTypes?: string[];\n\t// List of files.\n\tfilesList: File[];\n\t// Maximum upload size in bytes allowed for the site.\n\tmaxUploadFileSize?: number;\n\t// Function called when an error happens.\n\tonError?: OnErrorHandler;\n\t// Function called each time a file or a temporary representation of the file is available.\n\tonFileChange?: OnChangeHandler;\n\t// Function called once a file has completely finished uploading, including thumbnails.\n\tonSuccess?: OnSuccessHandler;\n\t// List of allowed mime types and file extensions.\n\twpAllowedMimeTypes?: Record< string, string > | null;\n\t// Abort signal.\n\tsignal?: AbortSignal;\n}\n\nexport interface Settings {\n\t// Function for uploading files to the server.\n\tmediaUpload: ( args: UploadMediaArgs ) => void;\n\t// List of allowed mime types and file extensions.\n\tallowedMimeTypes?: Record< string, string > | null;\n\t// Maximum upload file size\n\tmaxUploadFileSize?: number;\n}\n\n// Must match the Attachment type from the media-utils package.\nexport interface Attachment {\n\tid: number;\n\talt: string;\n\tcaption: string;\n\ttitle: string;\n\turl: string;\n\tfilename: string | null;\n\tfilesize: number | null;\n\tmedia_type: 'image' | 'file';\n\tmime_type: string;\n\tfeatured_media?: number;\n\tmissing_image_sizes?: string[];\n\tposter?: string;\n}\n\nexport type OnChangeHandler = ( attachments: Partial< Attachment >[] ) => void;\nexport type OnSuccessHandler = ( attachments: Partial< Attachment >[] ) => void;\nexport type OnErrorHandler = ( error: Error ) => void;\nexport type OnBatchSuccessHandler = () => void;\n\nexport enum ItemStatus {\n\tProcessing = 'PROCESSING',\n\tPaused = 'PAUSED',\n}\n\nexport enum OperationType {\n\tPrepare = 'PREPARE',\n\tUpload = 'UPLOAD',\n}\n\nexport interface OperationArgs {}\n\ntype OperationWithArgs< T extends keyof OperationArgs = keyof OperationArgs > =\n\t[ T, OperationArgs[ T ] ];\n\nexport type Operation = OperationType | OperationWithArgs;\n\nexport type AdditionalData = Record< string, unknown >;\n\nexport type ImageFormat = 'jpeg' | 'webp' | 'avif' | 'png' | 'gif';\n","/**\n * Internal dependencies\n */\nimport {\n\ttype AddAction,\n\ttype AddOperationsAction,\n\ttype CacheBlobUrlAction,\n\ttype CancelAction,\n\ttype OperationFinishAction,\n\ttype OperationStartAction,\n\ttype PauseQueueAction,\n\ttype QueueItem,\n\ttype RemoveAction,\n\ttype ResumeQueueAction,\n\ttype RevokeBlobUrlsAction,\n\ttype State,\n\tType,\n\ttype UnknownAction,\n\ttype UpdateSettingsAction,\n} from './types';\n\nconst noop = () => {};\n\nconst DEFAULT_STATE: State = {\n\tqueue: [],\n\tqueueStatus: 'active',\n\tblobUrls: {},\n\tsettings: {\n\t\tmediaUpload: noop,\n\t},\n};\n\ntype Action =\n\t| AddAction\n\t| RemoveAction\n\t| CancelAction\n\t| PauseQueueAction\n\t| ResumeQueueAction\n\t| AddOperationsAction\n\t| OperationFinishAction\n\t| OperationStartAction\n\t| CacheBlobUrlAction\n\t| RevokeBlobUrlsAction\n\t| UpdateSettingsAction\n\t| UnknownAction;\n\nfunction reducer(\n\tstate = DEFAULT_STATE,\n\taction: Action = { type: Type.Unknown }\n) {\n\tswitch ( action.type ) {\n\t\tcase Type.PauseQueue: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueueStatus: 'paused',\n\t\t\t};\n\t\t}\n\n\t\tcase Type.ResumeQueue: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueueStatus: 'active',\n\t\t\t};\n\t\t}\n\n\t\tcase Type.Add:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: [ ...state.queue, action.item ],\n\t\t\t};\n\n\t\tcase Type.Cancel:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\terror: action.error,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase Type.Remove:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.filter( ( item ) => item.id !== action.id ),\n\t\t\t};\n\n\t\tcase Type.OperationStart: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map(\n\t\t\t\t\t( item ): QueueItem =>\n\t\t\t\t\t\titem.id === action.id\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item,\n\t\t\t\t\t\t\t\t\tcurrentOperation: action.operation,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: item\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tcase Type.AddOperations:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map( ( item ): QueueItem => {\n\t\t\t\t\tif ( item.id !== action.id ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\toperations: [\n\t\t\t\t\t\t\t...( item.operations || [] ),\n\t\t\t\t\t\t\t...action.operations,\n\t\t\t\t\t\t],\n\t\t\t\t\t};\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase Type.OperationFinish:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tqueue: state.queue.map( ( item ): QueueItem => {\n\t\t\t\t\tif ( item.id !== action.id ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst operations = item.operations\n\t\t\t\t\t\t? item.operations.slice( 1 )\n\t\t\t\t\t\t: [];\n\n\t\t\t\t\t// Prevent an empty object if there's no attachment data.\n\t\t\t\t\tconst attachment =\n\t\t\t\t\t\titem.attachment || action.item.attachment\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t...item.attachment,\n\t\t\t\t\t\t\t\t\t...action.item.attachment,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: undefined;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...item,\n\t\t\t\t\t\tcurrentOperation: undefined,\n\t\t\t\t\t\toperations,\n\t\t\t\t\t\t...action.item,\n\t\t\t\t\t\tattachment,\n\t\t\t\t\t\tadditionalData: {\n\t\t\t\t\t\t\t...item.additionalData,\n\t\t\t\t\t\t\t...action.item.additionalData,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase Type.CacheBlobUrl: {\n\t\t\tconst blobUrls = state.blobUrls[ action.id ] || [];\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tblobUrls: {\n\t\t\t\t\t...state.blobUrls,\n\t\t\t\t\t[ action.id ]: [ ...blobUrls, action.blobUrl ],\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tcase Type.RevokeBlobUrls: {\n\t\t\tconst newBlobUrls = { ...state.blobUrls };\n\t\t\tdelete newBlobUrls[ action.id ];\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tblobUrls: newBlobUrls,\n\t\t\t};\n\t\t}\n\n\t\tcase Type.UpdateSettings: {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tsettings: {\n\t\t\t\t\t...state.settings,\n\t\t\t\t\t...action.settings,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\treturn state;\n}\n\nexport default reducer;\n","/**\n * Internal dependencies\n */\nimport type { QueueItem, Settings, State } from './types';\n\n/**\n * Returns all items currently being uploaded.\n *\n * @param state Upload state.\n *\n * @return Queue items.\n */\nexport function getItems( state: State ): QueueItem[] {\n\treturn state.queue;\n}\n\n/**\n * Determines whether any upload is currently in progress.\n *\n * @param state Upload state.\n *\n * @return Whether any upload is currently in progress.\n */\nexport function isUploading( state: State ): boolean {\n\treturn state.queue.length >= 1;\n}\n\n/**\n * Determines whether an upload is currently in progress given an attachment URL.\n *\n * @param state Upload state.\n * @param url   Attachment URL.\n *\n * @return Whether upload is currently in progress for the given attachment.\n */\nexport function isUploadingByUrl( state: State, url: string ): boolean {\n\treturn state.queue.some(\n\t\t( item ) => item.attachment?.url === url || item.sourceUrl === url\n\t);\n}\n\n/**\n * Determines whether an upload is currently in progress given an attachment ID.\n *\n * @param state        Upload state.\n * @param attachmentId Attachment ID.\n *\n * @return Whether upload is currently in progress for the given attachment.\n */\nexport function isUploadingById( state: State, attachmentId: number ): boolean {\n\treturn state.queue.some(\n\t\t( item ) =>\n\t\t\titem.attachment?.id === attachmentId ||\n\t\t\titem.sourceAttachmentId === attachmentId\n\t);\n}\n\n/**\n * Returns the media upload settings.\n *\n * @param state Upload state.\n *\n * @return Settings\n */\nexport function getSettings( state: State ): Settings {\n\treturn state.settings;\n}\n","/**\n * Internal dependencies\n */\nimport {\n\ttype BatchId,\n\tItemStatus,\n\tOperationType,\n\ttype QueueItem,\n\ttype QueueItemId,\n\ttype State,\n} from './types';\n\n/**\n * Returns all items currently being uploaded.\n *\n * @param state Upload state.\n *\n * @return Queue items.\n */\nexport function getAllItems( state: State ): QueueItem[] {\n\treturn state.queue;\n}\n\n/**\n * Returns a specific item given its unique ID.\n *\n * @param state Upload state.\n * @param id    Item ID.\n *\n * @return Queue item.\n */\nexport function getItem(\n\tstate: State,\n\tid: QueueItemId\n): QueueItem | undefined {\n\treturn state.queue.find( ( item ) => item.id === id );\n}\n\n/**\n * Determines whether a batch has been successfully uploaded, given its unique ID.\n *\n * @param state   Upload state.\n * @param batchId Batch ID.\n *\n * @return Whether a batch has been uploaded.\n */\nexport function isBatchUploaded( state: State, batchId: BatchId ): boolean {\n\tconst batchItems = state.queue.filter(\n\t\t( item ) => batchId === item.batchId\n\t);\n\treturn batchItems.length === 0;\n}\n\n/**\n * Determines whether an upload is currently in progress given a post or attachment ID.\n *\n * @param state              Upload state.\n * @param postOrAttachmentId Post ID or attachment ID.\n *\n * @return Whether upload is currently in progress for the given post or attachment.\n */\nexport function isUploadingToPost(\n\tstate: State,\n\tpostOrAttachmentId: number\n): boolean {\n\treturn state.queue.some(\n\t\t( item ) =>\n\t\t\titem.currentOperation === OperationType.Upload &&\n\t\t\titem.additionalData.post === postOrAttachmentId\n\t);\n}\n\n/**\n * Returns the next paused upload for a given post or attachment ID.\n *\n * @param state              Upload state.\n * @param postOrAttachmentId Post ID or attachment ID.\n *\n * @return Paused item.\n */\nexport function getPausedUploadForPost(\n\tstate: State,\n\tpostOrAttachmentId: number\n): QueueItem | undefined {\n\treturn state.queue.find(\n\t\t( item ) =>\n\t\t\titem.status === ItemStatus.Paused &&\n\t\t\titem.additionalData.post === postOrAttachmentId\n\t);\n}\n\n/**\n * Determines whether uploading is currently paused.\n *\n * @param state Upload state.\n *\n * @return Whether uploading is currently paused.\n */\nexport function isPaused( state: State ): boolean {\n\treturn state.queueStatus === 'paused';\n}\n\n/**\n * Returns all cached blob URLs for a given item ID.\n *\n * @param state Upload state.\n * @param id    Item ID\n *\n * @return List of blob URLs.\n */\nexport function getBlobUrls( state: State, id: QueueItemId ): string[] {\n\treturn state.blobUrls[ id ] || [];\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"i18n\"];","interface UploadErrorArgs {\n\tcode: string;\n\tmessage: string;\n\tfile: File;\n\tcause?: Error;\n}\n\n/**\n * MediaError class.\n *\n * Small wrapper around the `Error` class\n * to hold an error code and a reference to a file object.\n */\nexport class UploadError extends Error {\n\tcode: string;\n\tfile: File;\n\n\tconstructor( { code, message, file, cause }: UploadErrorArgs ) {\n\t\tsuper( message, { cause } );\n\n\t\tObject.setPrototypeOf( this, new.target.prototype );\n\n\t\tthis.code = code;\n\t\tthis.file = file;\n\t}\n}\n","/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\n\n/**\n * Verifies if the caller (e.g. a block) supports this mime type.\n *\n * @param file         File object.\n * @param allowedTypes List of allowed mime types.\n */\nexport function validateMimeType( file: File, allowedTypes?: string[] ) {\n\tif ( ! allowedTypes ) {\n\t\treturn;\n\t}\n\n\t// Allowed type specified by consumer.\n\tconst isAllowedType = allowedTypes.some( ( allowedType ) => {\n\t\t// If a complete mimetype is specified verify if it matches exactly the mime type of the file.\n\t\tif ( allowedType.includes( '/' ) ) {\n\t\t\treturn allowedType === file.type;\n\t\t}\n\t\t// Otherwise a general mime type is used, and we should verify if the file mimetype starts with it.\n\t\treturn file.type.startsWith( `${ allowedType }/` );\n\t} );\n\n\tif ( file.type && ! isAllowedType ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'MIME_TYPE_NOT_SUPPORTED',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__( '%s: Sorry, this file type is not supported here.' ),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n","/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\nimport { getMimeTypesArray } from './get-mime-types-array';\n\n/**\n * Verifies if the user is allowed to upload this mime type.\n *\n * @param file               File object.\n * @param wpAllowedMimeTypes List of allowed mime types and file extensions.\n */\nexport function validateMimeTypeForUser(\n\tfile: File,\n\twpAllowedMimeTypes?: Record< string, string > | null\n) {\n\t// Allowed types for the current WP_User.\n\tconst allowedMimeTypesForUser = getMimeTypesArray( wpAllowedMimeTypes );\n\n\tif ( ! allowedMimeTypesForUser ) {\n\t\treturn;\n\t}\n\n\tconst isAllowedMimeTypeForUser = allowedMimeTypesForUser.includes(\n\t\tfile.type\n\t);\n\n\tif ( file.type && ! isAllowedMimeTypeForUser ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'MIME_TYPE_NOT_ALLOWED_FOR_USER',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__(\n\t\t\t\t\t'%s: Sorry, you are not allowed to upload this file type.'\n\t\t\t\t),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n","/**\n * Browsers may use unexpected mime types, and they differ from browser to browser.\n * This function computes a flexible array of mime types from the mime type structured provided by the server.\n * Converts { jpg|jpeg|jpe: \"image/jpeg\" } into [ \"image/jpeg\", \"image/jpg\", \"image/jpeg\", \"image/jpe\" ]\n *\n * @param {?Object} wpMimeTypesObject Mime type object received from the server.\n *                                    Extensions are keys separated by '|' and values are mime types associated with an extension.\n *\n * @return An array of mime types or null\n */\nexport function getMimeTypesArray(\n\twpMimeTypesObject?: Record< string, string > | null\n) {\n\tif ( ! wpMimeTypesObject ) {\n\t\treturn null;\n\t}\n\treturn Object.entries( wpMimeTypesObject ).flatMap(\n\t\t( [ extensionsString, mime ] ) => {\n\t\t\tconst [ type ] = mime.split( '/' );\n\t\t\tconst extensions = extensionsString.split( '|' );\n\t\t\treturn [\n\t\t\t\tmime,\n\t\t\t\t...extensions.map(\n\t\t\t\t\t( extension ) => `${ type }/${ extension }`\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\t);\n}\n","/**\n * WordPress dependencies\n */\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { UploadError } from './upload-error';\n\n/**\n * Verifies whether the file is within the file upload size limits for the site.\n *\n * @param file              File object.\n * @param maxUploadFileSize Maximum upload size in bytes allowed for the site.\n */\nexport function validateFileSize( file: File, maxUploadFileSize?: number ) {\n\t// Don't allow empty files to be uploaded.\n\tif ( file.size <= 0 ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'EMPTY_FILE',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__( '%s: This file is empty.' ),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n\n\tif ( maxUploadFileSize && file.size > maxUploadFileSize ) {\n\t\tthrow new UploadError( {\n\t\t\tcode: 'SIZE_ABOVE_LIMIT',\n\t\t\tmessage: sprintf(\n\t\t\t\t// translators: %s: file name.\n\t\t\t\t__(\n\t\t\t\t\t'%s: This file exceeds the maximum upload size for this site.'\n\t\t\t\t),\n\t\t\t\tfile.name\n\t\t\t),\n\t\t\tfile,\n\t\t} );\n\t}\n}\n","/**\n * External dependencies\n */\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport type { createRegistry } from '@wordpress/data';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\n/**\n * Internal dependencies\n */\nimport type {\n\tAdditionalData,\n\tCancelAction,\n\tOnBatchSuccessHandler,\n\tOnChangeHandler,\n\tOnErrorHandler,\n\tOnSuccessHandler,\n\tQueueItemId,\n\tState,\n} from './types';\nimport { Type } from './types';\nimport type {\n\taddItem,\n\tprocessItem,\n\tremoveItem,\n\trevokeBlobUrls,\n} from './private-actions';\nimport { validateMimeType } from '../validate-mime-type';\nimport { validateMimeTypeForUser } from '../validate-mime-type-for-user';\nimport { validateFileSize } from '../validate-file-size';\n\ntype ActionCreators = {\n\taddItem: typeof addItem;\n\taddItems: typeof addItems;\n\tremoveItem: typeof removeItem;\n\tprocessItem: typeof processItem;\n\tcancelItem: typeof cancelItem;\n\trevokeBlobUrls: typeof revokeBlobUrls;\n\t< T = Record< string, unknown > >( args: T ): void;\n};\n\ntype AllSelectors = typeof import('./selectors') &\n\ttypeof import('./private-selectors');\ntype CurriedState< F > = F extends ( state: State, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\ntype Selectors = {\n\t[ key in keyof AllSelectors ]: CurriedState< AllSelectors[ key ] >;\n};\n\ntype ThunkArgs = {\n\tselect: Selectors;\n\tdispatch: ActionCreators;\n\tregistry: WPDataRegistry;\n};\n\ninterface AddItemsArgs {\n\tfiles: File[];\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tonError?: OnErrorHandler;\n\tadditionalData?: AdditionalData;\n\tallowedTypes?: string[];\n}\n\n/**\n * Adds a new item to the upload queue.\n *\n * @param $0\n * @param $0.files            Files\n * @param [$0.onChange]       Function called each time a file or a temporary representation of the file is available.\n * @param [$0.onSuccess]      Function called after the file is uploaded.\n * @param [$0.onBatchSuccess] Function called after a batch of files is uploaded.\n * @param [$0.onError]        Function called when an error happens.\n * @param [$0.additionalData] Additional data to include in the request.\n * @param [$0.allowedTypes]   Array with the types of media that can be uploaded, if unset all types are allowed.\n */\nexport function addItems( {\n\tfiles,\n\tonChange,\n\tonSuccess,\n\tonError,\n\tonBatchSuccess,\n\tadditionalData,\n\tallowedTypes,\n}: AddItemsArgs ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst batchId = uuidv4();\n\t\tfor ( const file of files ) {\n\t\t\t/*\n\t\t\t Check if the caller (e.g. a block) supports this mime type.\n\t\t\t Special case for file types such as HEIC which will be converted before upload anyway.\n\t\t\t Another check will be done before upload.\n\t\t\t*/\n\t\t\ttry {\n\t\t\t\tvalidateMimeType( file, allowedTypes );\n\t\t\t\tvalidateMimeTypeForUser(\n\t\t\t\t\tfile,\n\t\t\t\t\tselect.getSettings().allowedMimeTypes\n\t\t\t\t);\n\t\t\t} catch ( error: unknown ) {\n\t\t\t\tonError?.( error as Error );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalidateFileSize(\n\t\t\t\t\tfile,\n\t\t\t\t\tselect.getSettings().maxUploadFileSize\n\t\t\t\t);\n\t\t\t} catch ( error: unknown ) {\n\t\t\t\tonError?.( error as Error );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdispatch.addItem( {\n\t\t\t\tfile,\n\t\t\t\tbatchId,\n\t\t\t\tonChange,\n\t\t\t\tonSuccess,\n\t\t\t\tonBatchSuccess,\n\t\t\t\tonError,\n\t\t\t\tadditionalData,\n\t\t\t} );\n\t\t}\n\t};\n}\n\n/**\n * Cancels an item in the queue based on an error.\n *\n * @param id     Item ID.\n * @param error  Error instance.\n * @param silent Whether to cancel the item silently,\n *               without invoking its `onError` callback.\n */\nexport function cancelItem( id: QueueItemId, error: Error, silent = false ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\n\t\tif ( ! item ) {\n\t\t\t/*\n\t\t\t * Do nothing if item has already been removed.\n\t\t\t * This can happen if an upload is cancelled manually\n\t\t\t * while transcoding with vips is still in progress.\n\t\t\t * Then, cancelItem() is once invoked manually and once\n\t\t\t * by the error handler in optimizeImageItem().\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\titem.abortController?.abort();\n\n\t\tif ( ! silent ) {\n\t\t\tconst { onError } = item;\n\t\t\tonError?.( error ?? new Error( 'Upload cancelled' ) );\n\t\t\tif ( ! onError && error ) {\n\t\t\t\t// TODO: Find better way to surface errors with sideloads etc.\n\t\t\t\t// eslint-disable-next-line no-console -- Deliberately log errors here.\n\t\t\t\tconsole.error( 'Upload cancelled', error );\n\t\t\t}\n\t\t}\n\n\t\tdispatch< CancelAction >( {\n\t\t\ttype: Type.Cancel,\n\t\t\tid,\n\t\t\terror,\n\t\t} );\n\t\tdispatch.removeItem( id );\n\t\tdispatch.revokeBlobUrls( id );\n\n\t\t// All items of this batch were cancelled or finished.\n\t\tif ( item.batchId && select.isBatchUploaded( item.batchId ) ) {\n\t\t\titem.onBatchSuccess?.();\n\t\t}\n\t};\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"blob\"];","/**\n * WordPress dependencies\n */\nimport { getFilename } from '@wordpress/url';\nimport { _x } from '@wordpress/i18n';\n\n/**\n * Converts a Blob to a File with a default name like \"image.png\".\n *\n * If it is already a File object, it is returned unchanged.\n *\n * @param fileOrBlob Blob object.\n * @return File object.\n */\nexport function convertBlobToFile( fileOrBlob: Blob | File ): File {\n\tif ( fileOrBlob instanceof File ) {\n\t\treturn fileOrBlob;\n\t}\n\n\t// Extension is only an approximation.\n\t// The server will override it if incorrect.\n\tconst ext = fileOrBlob.type.split( '/' )[ 1 ];\n\tconst mediaType =\n\t\t'application/pdf' === fileOrBlob.type\n\t\t\t? 'document'\n\t\t\t: fileOrBlob.type.split( '/' )[ 0 ];\n\treturn new File( [ fileOrBlob ], `${ mediaType }.${ ext }`, {\n\t\ttype: fileOrBlob.type,\n\t} );\n}\n\n/**\n * Renames a given file and returns a new file.\n *\n * Copies over the last modified time.\n *\n * @param file File object.\n * @param name File name.\n * @return Renamed file object.\n */\nexport function renameFile( file: File, name: string ): File {\n\treturn new File( [ file ], name, {\n\t\ttype: file.type,\n\t\tlastModified: file.lastModified,\n\t} );\n}\n\n/**\n * Clones a given file object.\n *\n * @param file File object.\n * @return New file object.\n */\nexport function cloneFile( file: File ): File {\n\treturn renameFile( file, file.name );\n}\n\n/**\n * Returns the file extension from a given file name or URL.\n *\n * @param file File URL.\n * @return File extension or null if it does not have one.\n */\nexport function getFileExtension( file: string ): string | null {\n\treturn file.includes( '.' ) ? file.split( '.' ).pop() || null : null;\n}\n\n/**\n * Returns file basename without extension.\n *\n * For example, turns \"my-awesome-file.jpeg\" into \"my-awesome-file\".\n *\n * @param name File name.\n * @return File basename.\n */\nexport function getFileBasename( name: string ): string {\n\treturn name.includes( '.' )\n\t\t? name.split( '.' ).slice( 0, -1 ).join( '.' )\n\t\t: name;\n}\n\n/**\n * Returns the file name including extension from a URL.\n *\n * @param url File URL.\n * @return File name.\n */\nexport function getFileNameFromUrl( url: string ) {\n\treturn getFilename( url ) || _x( 'unnamed', 'file name' );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"url\"];","export class StubFile extends File {\n\tconstructor( fileName = 'stub-file' ) {\n\t\tsuper( [], fileName );\n\t}\n}\n","/**\n * External dependencies\n */\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport { createBlobURL, isBlobURL, revokeBlobURL } from '@wordpress/blob';\nimport type { createRegistry } from '@wordpress/data';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\n/**\n * Internal dependencies\n */\nimport { cloneFile, convertBlobToFile } from '../utils';\nimport { StubFile } from '../stub-file';\nimport type {\n\tAddAction,\n\tAdditionalData,\n\tAddOperationsAction,\n\tBatchId,\n\tCacheBlobUrlAction,\n\tOnBatchSuccessHandler,\n\tOnChangeHandler,\n\tOnErrorHandler,\n\tOnSuccessHandler,\n\tOperation,\n\tOperationFinishAction,\n\tOperationStartAction,\n\tPauseQueueAction,\n\tQueueItem,\n\tQueueItemId,\n\tResumeQueueAction,\n\tRevokeBlobUrlsAction,\n\tSettings,\n\tState,\n\tUpdateSettingsAction,\n} from './types';\nimport { ItemStatus, OperationType, Type } from './types';\nimport type { cancelItem } from './actions';\n\ntype ActionCreators = {\n\tcancelItem: typeof cancelItem;\n\taddItem: typeof addItem;\n\tremoveItem: typeof removeItem;\n\tprepareItem: typeof prepareItem;\n\tprocessItem: typeof processItem;\n\tfinishOperation: typeof finishOperation;\n\tuploadItem: typeof uploadItem;\n\trevokeBlobUrls: typeof revokeBlobUrls;\n\t< T = Record< string, unknown > >( args: T ): void;\n};\n\ntype AllSelectors = typeof import('./selectors') &\n\ttypeof import('./private-selectors');\ntype CurriedState< F > = F extends ( state: State, ...args: infer P ) => infer R\n\t? ( ...args: P ) => R\n\t: F;\ntype Selectors = {\n\t[ key in keyof AllSelectors ]: CurriedState< AllSelectors[ key ] >;\n};\n\ntype ThunkArgs = {\n\tselect: Selectors;\n\tdispatch: ActionCreators;\n\tregistry: WPDataRegistry;\n};\n\ninterface AddItemArgs {\n\t// It should always be a File, but some consumers might still pass Blobs only.\n\tfile: File | Blob;\n\tbatchId?: BatchId;\n\tonChange?: OnChangeHandler;\n\tonSuccess?: OnSuccessHandler;\n\tonError?: OnErrorHandler;\n\tonBatchSuccess?: OnBatchSuccessHandler;\n\tadditionalData?: AdditionalData;\n\tsourceUrl?: string;\n\tsourceAttachmentId?: number;\n\tabortController?: AbortController;\n\toperations?: Operation[];\n}\n\n/**\n * Adds a new item to the upload queue.\n *\n * @param $0\n * @param $0.file                 File\n * @param [$0.batchId]            Batch ID.\n * @param [$0.onChange]           Function called each time a file or a temporary representation of the file is available.\n * @param [$0.onSuccess]          Function called after the file is uploaded.\n * @param [$0.onBatchSuccess]     Function called after a batch of files is uploaded.\n * @param [$0.onError]            Function called when an error happens.\n * @param [$0.additionalData]     Additional data to include in the request.\n * @param [$0.sourceUrl]          Source URL. Used when importing a file from a URL or optimizing an existing file.\n * @param [$0.sourceAttachmentId] Source attachment ID. Used when optimizing an existing file for example.\n * @param [$0.abortController]    Abort controller for upload cancellation.\n * @param [$0.operations]         List of operations to perform. Defaults to automatically determined list, based on the file.\n */\nexport function addItem( {\n\tfile: fileOrBlob,\n\tbatchId,\n\tonChange,\n\tonSuccess,\n\tonBatchSuccess,\n\tonError,\n\tadditionalData = {} as AdditionalData,\n\tsourceUrl,\n\tsourceAttachmentId,\n\tabortController,\n\toperations,\n}: AddItemArgs ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tconst itemId = uuidv4();\n\n\t\t// Hardening in case a Blob is passed instead of a File.\n\t\t// See https://github.com/WordPress/gutenberg/pull/65693 for an example.\n\t\tconst file = convertBlobToFile( fileOrBlob );\n\n\t\tlet blobUrl;\n\n\t\t// StubFile could be coming from addItemFromUrl().\n\t\tif ( ! ( file instanceof StubFile ) ) {\n\t\t\tblobUrl = createBlobURL( file );\n\t\t\tdispatch< CacheBlobUrlAction >( {\n\t\t\t\ttype: Type.CacheBlobUrl,\n\t\t\t\tid: itemId,\n\t\t\t\tblobUrl,\n\t\t\t} );\n\t\t}\n\n\t\tdispatch< AddAction >( {\n\t\t\ttype: Type.Add,\n\t\t\titem: {\n\t\t\t\tid: itemId,\n\t\t\t\tbatchId,\n\t\t\t\tstatus: ItemStatus.Processing,\n\t\t\t\tsourceFile: cloneFile( file ),\n\t\t\t\tfile,\n\t\t\t\tattachment: {\n\t\t\t\t\turl: blobUrl,\n\t\t\t\t},\n\t\t\t\tadditionalData: {\n\t\t\t\t\tconvert_format: false,\n\t\t\t\t\t...additionalData,\n\t\t\t\t},\n\t\t\t\tonChange,\n\t\t\t\tonSuccess,\n\t\t\t\tonBatchSuccess,\n\t\t\t\tonError,\n\t\t\t\tsourceUrl,\n\t\t\t\tsourceAttachmentId,\n\t\t\t\tabortController: abortController || new AbortController(),\n\t\t\t\toperations: Array.isArray( operations )\n\t\t\t\t\t? operations\n\t\t\t\t\t: [ OperationType.Prepare ],\n\t\t\t},\n\t\t} );\n\n\t\tdispatch.processItem( itemId );\n\t};\n}\n\n/**\n * Processes a single item in the queue.\n *\n * Runs the next operation in line and invokes any callbacks.\n *\n * @param id Item ID.\n */\nexport function processItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tif ( select.isPaused() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = select.getItem( id ) as QueueItem;\n\n\t\tconst { attachment, onChange, onSuccess, onBatchSuccess, batchId } =\n\t\t\titem;\n\n\t\tconst operation = Array.isArray( item.operations?.[ 0 ] )\n\t\t\t? item.operations[ 0 ][ 0 ]\n\t\t\t: item.operations?.[ 0 ];\n\n\t\tif ( attachment ) {\n\t\t\tonChange?.( [ attachment ] );\n\t\t}\n\n\t\t/*\n\t\t If there are no more operations, the item can be removed from the queue,\n\t\t but only if there are no thumbnails still being side-loaded,\n\t\t or if itself is a side-loaded item.\n\t\t*/\n\n\t\tif ( ! operation ) {\n\t\t\tif ( attachment ) {\n\t\t\t\tonSuccess?.( [ attachment ] );\n\t\t\t}\n\n\t\t\t// dispatch.removeItem( id );\n\t\t\tdispatch.revokeBlobUrls( id );\n\n\t\t\tif ( batchId && select.isBatchUploaded( batchId ) ) {\n\t\t\t\tonBatchSuccess?.();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t At this point we are dealing with a parent whose children haven't fully uploaded yet.\n\t\t\t Do nothing and let the removal happen once the last side-loaded item finishes.\n\t\t\t */\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! operation ) {\n\t\t\t// This shouldn't really happen.\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch< OperationStartAction >( {\n\t\t\ttype: Type.OperationStart,\n\t\t\tid,\n\t\t\toperation,\n\t\t} );\n\n\t\tswitch ( operation ) {\n\t\t\tcase OperationType.Prepare:\n\t\t\t\tdispatch.prepareItem( item.id );\n\t\t\t\tbreak;\n\n\t\t\tcase OperationType.Upload:\n\t\t\t\tdispatch.uploadItem( id );\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\n/**\n * Returns an action object that pauses all processing in the queue.\n *\n * Useful for testing purposes.\n *\n * @return Action object.\n */\nexport function pauseQueue(): PauseQueueAction {\n\treturn {\n\t\ttype: Type.PauseQueue,\n\t};\n}\n\n/**\n * Resumes all processing in the queue.\n *\n * Dispatches an action object for resuming the queue itself,\n * and triggers processing for each remaining item in the queue individually.\n */\nexport function resumeQueue() {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tdispatch< ResumeQueueAction >( {\n\t\t\ttype: Type.ResumeQueue,\n\t\t} );\n\n\t\tfor ( const item of select.getAllItems() ) {\n\t\t\tdispatch.processItem( item.id );\n\t\t}\n\t};\n}\n\n/**\n * Removes a specific item from the queue.\n *\n * @param id Item ID.\n */\nexport function removeItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id );\n\t\tif ( ! item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch( {\n\t\t\ttype: Type.Remove,\n\t\t\tid,\n\t\t} );\n\t};\n}\n\n/**\n * Finishes an operation for a given item ID and immediately triggers processing the next one.\n *\n * @param id      Item ID.\n * @param updates Updated item data.\n */\nexport function finishOperation(\n\tid: QueueItemId,\n\tupdates: Partial< QueueItem >\n) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tdispatch< OperationFinishAction >( {\n\t\t\ttype: Type.OperationFinish,\n\t\t\tid,\n\t\t\titem: updates,\n\t\t} );\n\n\t\tdispatch.processItem( id );\n\t};\n}\n\n/**\n * Prepares an item for initial processing.\n *\n * Determines the list of operations to perform for a given image,\n * depending on its media type.\n *\n * For example, HEIF images first need to be converted, resized,\n * compressed, and then uploaded.\n *\n * Or videos need to be compressed, and then need poster generation\n * before upload.\n *\n * @param id Item ID.\n */\nexport function prepareItem( id: QueueItemId ) {\n\treturn async ( { dispatch }: ThunkArgs ) => {\n\t\tconst operations: Operation[] = [ OperationType.Upload ];\n\n\t\tdispatch< AddOperationsAction >( {\n\t\t\ttype: Type.AddOperations,\n\t\t\tid,\n\t\t\toperations,\n\t\t} );\n\n\t\tdispatch.finishOperation( id, {} );\n\t};\n}\n\n/**\n * Uploads an item to the server.\n *\n * @param id Item ID.\n */\nexport function uploadItem( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst item = select.getItem( id ) as QueueItem;\n\n\t\tselect.getSettings().mediaUpload( {\n\t\t\tfilesList: [ item.file ],\n\t\t\tadditionalData: item.additionalData,\n\t\t\tsignal: item.abortController?.signal,\n\t\t\tonFileChange: ( [ attachment ] ) => {\n\t\t\t\tif ( ! isBlobURL( attachment.url ) ) {\n\t\t\t\t\tdispatch.finishOperation( id, {\n\t\t\t\t\t\tattachment,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSuccess: ( [ attachment ] ) => {\n\t\t\t\tdispatch.finishOperation( id, {\n\t\t\t\t\tattachment,\n\t\t\t\t} );\n\t\t\t},\n\t\t\tonError: ( error ) => {\n\t\t\t\tdispatch.cancelItem( id, error );\n\t\t\t},\n\t\t} );\n\t};\n}\n\n/**\n * Revokes all blob URLs for a given item, freeing up memory.\n *\n * @param id Item ID.\n */\nexport function revokeBlobUrls( id: QueueItemId ) {\n\treturn async ( { select, dispatch }: ThunkArgs ) => {\n\t\tconst blobUrls = select.getBlobUrls( id );\n\n\t\tfor ( const blobUrl of blobUrls ) {\n\t\t\trevokeBlobURL( blobUrl );\n\t\t}\n\n\t\tdispatch< RevokeBlobUrlsAction >( {\n\t\t\ttype: Type.RevokeBlobUrls,\n\t\t\tid,\n\t\t} );\n\t};\n}\n\n/**\n * Returns an action object that pauses all processing in the queue.\n *\n * Useful for testing purposes.\n *\n * @param settings\n * @return Action object.\n */\nexport function updateSettings(\n\tsettings: Partial< Settings >\n): UpdateSettingsAction {\n\treturn {\n\t\ttype: Type.UpdateSettings,\n\t\tsettings,\n\t};\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"privateApis\"];","/**\n * WordPress dependencies\n */\nimport { __dangerousOptInToUnstableAPIsOnlyForCoreModules } from '@wordpress/private-apis';\n\nexport const { lock, unlock } =\n\t__dangerousOptInToUnstableAPIsOnlyForCoreModules(\n\t\t'I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.',\n\t\t'@wordpress/upload-media'\n\t);\n","export const STORE_NAME = 'core/upload-media';\n","/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as privateSelectors from './private-selectors';\nimport * as actions from './actions';\nimport * as privateActions from './private-actions';\nimport { unlock } from '../lock-unlock';\nimport { STORE_NAME } from './constants';\n\n/**\n * Media upload data store configuration.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore\n */\nexport const storeConfig = {\n\treducer,\n\tselectors,\n\tactions,\n};\n\n/**\n * Store definition for the media upload namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\nregister( store );\n// @ts-ignore\nunlock( store ).registerPrivateActions( privateActions );\n// @ts-ignore\nunlock( store ).registerPrivateSelectors( privateSelectors );\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"element\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"compose\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"ReactJSXRuntime\"];","/**\n * WordPress dependencies\n */\nimport { useEffect } from '@wordpress/element';\nimport { useDispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport withRegistryProvider from './with-registry-provider';\nimport { unlock } from '../../lock-unlock';\nimport { store as uploadStore } from '../../store';\n\nconst MediaUploadProvider = withRegistryProvider( ( props: any ) => {\n\tconst { children, settings } = props;\n\tconst { updateSettings } = unlock( useDispatch( uploadStore ) );\n\n\tuseEffect( () => {\n\t\tupdateSettings( settings );\n\t}, [ settings, updateSettings ] );\n\n\treturn <>{ children }</>;\n} );\n\nexport default MediaUploadProvider;\n","/**\n * WordPress dependencies\n */\nimport { useState } from '@wordpress/element';\nimport { useRegistry, createRegistry, RegistryProvider } from '@wordpress/data';\nimport { createHigherOrderComponent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { storeConfig } from '../../store';\nimport { STORE_NAME as mediaUploadStoreName } from '../../store/constants';\n\ntype WPDataRegistry = ReturnType< typeof createRegistry >;\n\nfunction getSubRegistry(\n\tsubRegistries: WeakMap< WPDataRegistry, WPDataRegistry >,\n\tregistry: WPDataRegistry,\n\tuseSubRegistry: boolean\n) {\n\tif ( ! useSubRegistry ) {\n\t\treturn registry;\n\t}\n\tlet subRegistry = subRegistries.get( registry );\n\tif ( ! subRegistry ) {\n\t\tsubRegistry = createRegistry( {}, registry );\n\t\tsubRegistry.registerStore( mediaUploadStoreName, storeConfig );\n\t\tsubRegistries.set( registry, subRegistry );\n\t}\n\treturn subRegistry;\n}\n\nconst withRegistryProvider = createHigherOrderComponent(\n\t( WrappedComponent ) =>\n\t\t( { useSubRegistry = true, ...props } ) => {\n\t\t\tconst registry = useRegistry() as unknown as WPDataRegistry;\n\t\t\tconst [ subRegistries ] = useState<\n\t\t\t\tWeakMap< WPDataRegistry, WPDataRegistry >\n\t\t\t>( () => new WeakMap() );\n\t\t\tconst subRegistry = getSubRegistry(\n\t\t\t\tsubRegistries,\n\t\t\t\tregistry,\n\t\t\t\tuseSubRegistry\n\t\t\t);\n\n\t\t\tif ( subRegistry === registry ) {\n\t\t\t\treturn <WrappedComponent registry={ registry } { ...props } />;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\t<RegistryProvider value={ subRegistry }>\n\t\t\t\t\t<WrappedComponent registry={ subRegistry } { ...props } />\n\t\t\t\t</RegistryProvider>\n\t\t\t);\n\t\t},\n\t'withRegistryProvider'\n);\n\nexport default withRegistryProvider;\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","window","Type","ItemStatus","OperationType","DEFAULT_STATE","queue","queueStatus","blobUrls","settings","mediaUpload","noop","state","action","type","Unknown","PauseQueue","ResumeQueue","Add","item","Cancel","map","id","error","Remove","filter","OperationStart","currentOperation","operation","AddOperations","operations","OperationFinish","slice","attachment","undefined","additionalData","CacheBlobUrl","blobUrl","RevokeBlobUrls","newBlobUrls","UpdateSettings","getItems","isUploading","length","isUploadingByUrl","url","some","sourceUrl","isUploadingById","attachmentId","sourceAttachmentId","getSettings","getAllItems","getItem","find","isBatchUploaded","batchId","isUploadingToPost","postOrAttachmentId","Upload","post","getPausedUploadForPost","status","Paused","isPaused","getBlobUrls","randomUUID","crypto","bind","getRandomValues","rnds8","Uint8Array","rng","Error","byteToHex","i","push","toString","options","buf","offset","rnds","random","arr","unsafeStringify","UploadError","constructor","code","message","file","cause","super","setPrototypeOf","this","validateMimeType","allowedTypes","isAllowedType","allowedType","includes","startsWith","sprintf","__","name","validateMimeTypeForUser","wpAllowedMimeTypes","allowedMimeTypesForUser","wpMimeTypesObject","entries","flatMap","extensionsString","mime","split","extension","isAllowedMimeTypeForUser","validateFileSize","maxUploadFileSize","size","addItems","files","onChange","onSuccess","onError","onBatchSuccess","async","select","dispatch","uuidv4","allowedMimeTypes","addItem","cancelItem","silent","abortController","abort","console","removeItem","revokeBlobUrls","cloneFile","File","lastModified","renameFile","StubFile","fileName","fileOrBlob","itemId","ext","mediaType","convertBlobToFile","createBlobURL","Processing","sourceFile","convert_format","AbortController","Array","isArray","Prepare","processItem","prepareItem","uploadItem","pauseQueue","resumeQueue","finishOperation","updates","filesList","signal","onFileChange","isBlobURL","revokeBlobURL","updateSettings","lock","unlock","__dangerousOptInToUnstableAPIsOnlyForCoreModules","STORE_NAME","storeConfig","reducer","selectors","actions","store","createReduxStore","register","registerPrivateActions","privateActions","registerPrivateSelectors","privateSelectors","MediaUploadProvider","createHigherOrderComponent","WrappedComponent","useSubRegistry","props","registry","useRegistry","subRegistries","useState","WeakMap","subRegistry","createRegistry","registerStore","mediaUploadStoreName","set","getSubRegistry","_jsx","RegistryProvider","children","withRegistryProvider","useDispatch","uploadStore","useEffect","_Fragment"],"sourceRoot":""}