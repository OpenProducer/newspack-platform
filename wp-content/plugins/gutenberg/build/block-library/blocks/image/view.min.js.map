{"version":3,"file":"./build/block-library/blocks/image/view.min.js","mappings":"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","sources":["webpack://wp/external window [\"wp\",\"interactivity\"]","webpack://wp/./packages/block-library/build-module/image/@wordpress/block-library/src/image/view.js"],"sourcesContent":["var __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"interactivity\"];","/**\n * WordPress dependencies\n */\nimport { store } from '@wordpress/interactivity';\n\nconst focusableSelectors = [\n\t'a[href]',\n\t'area[href]',\n\t'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])',\n\t'select:not([disabled]):not([aria-hidden])',\n\t'textarea:not([disabled]):not([aria-hidden])',\n\t'button:not([disabled]):not([aria-hidden])',\n\t'iframe',\n\t'object',\n\t'embed',\n\t'[contenteditable]',\n\t'[tabindex]:not([tabindex^=\"-\"])',\n];\n\n/*\n * Stores a context-bound scroll handler.\n *\n * This callback could be defined inline inside of the store\n * object but it's created externally to avoid confusion about\n * how its logic is called. This logic is not referenced directly\n * by the directives in the markup because the scroll event we\n * need to listen to is triggered on the window; so by defining it\n * outside of the store, we signal that the behavior here is different.\n * If we find a compelling reason to move it to the store, feel free.\n *\n * @type {Function}\n */\nlet scrollCallback;\n\n/*\n * Tracks whether user is touching screen; used to\n * differentiate behavior for touch and mouse input.\n *\n * @type {boolean}\n */\nlet isTouching = false;\n\n/*\n * Tracks the last time the screen was touched; used to\n * differentiate behavior for touch and mouse input.\n *\n * @type {number}\n */\nlet lastTouchTime = 0;\n\n/*\n * Lightbox page-scroll handler: prevents scrolling.\n *\n * This handler is added to prevent scrolling behaviors that\n * trigger content shift while the lightbox is open.\n *\n * It would be better to accomplish this through CSS alone, but\n * using overflow: hidden is currently the only way to do so, and\n * that causes the layout to shift and prevents the zoom animation\n * from working in some cases because we're unable to account for\n * the layout shift when doing the animation calculations. Instead,\n * here we use JavaScript to prevent and reset the scrolling\n * behavior. In the future, we may be able to use CSS or overflow: hidden\n * instead to not rely on JavaScript, but this seems to be the best approach\n * for now that provides the best visual experience.\n *\n * @param {Object} context Interactivity page context?\n */\nfunction handleScroll( context ) {\n\t// We can't override the scroll behavior on mobile devices\n\t// because doing so breaks the pinch to zoom functionality, and we\n\t// want to allow users to zoom in further on the high-res image.\n\tif ( ! isTouching && Date.now() - lastTouchTime > 450 ) {\n\t\t// We are unable to use event.preventDefault() to prevent scrolling\n\t\t// because the scroll event can't be canceled, so we reset the position instead.\n\t\twindow.scrollTo(\n\t\t\tcontext.core.image.scrollLeftReset,\n\t\t\tcontext.core.image.scrollTopReset\n\t\t);\n\t}\n}\n\nstore(\n\t{\n\t\tstate: {\n\t\t\tcore: {\n\t\t\t\timage: {\n\t\t\t\t\twindowWidth: window.innerWidth,\n\t\t\t\t\twindowHeight: window.innerHeight,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tactions: {\n\t\t\tcore: {\n\t\t\t\timage: {\n\t\t\t\t\tshowLightbox: ( { context, event } ) => {\n\t\t\t\t\t\t// We can't initialize the lightbox until the reference\n\t\t\t\t\t\t// image is loaded, otherwise the UX is broken.\n\t\t\t\t\t\tif ( ! context.core.image.imageLoaded ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontext.core.image.initialized = true;\n\t\t\t\t\t\tcontext.core.image.lastFocusedElement =\n\t\t\t\t\t\t\twindow.document.activeElement;\n\t\t\t\t\t\tcontext.core.image.scrollDelta = 0;\n\t\t\t\t\t\tcontext.core.image.pointerType = event.pointerType;\n\n\t\t\t\t\t\tcontext.core.image.lightboxEnabled = true;\n\t\t\t\t\t\tsetStyles( context, context.core.image.imageRef );\n\n\t\t\t\t\t\tcontext.core.image.scrollTopReset =\n\t\t\t\t\t\t\twindow.pageYOffset ||\n\t\t\t\t\t\t\tdocument.documentElement.scrollTop;\n\n\t\t\t\t\t\t// In most cases, this value will be 0, but this is included\n\t\t\t\t\t\t// in case a user has created a page with horizontal scrolling.\n\t\t\t\t\t\tcontext.core.image.scrollLeftReset =\n\t\t\t\t\t\t\twindow.pageXOffset ||\n\t\t\t\t\t\t\tdocument.documentElement.scrollLeft;\n\n\t\t\t\t\t\t// We define and bind the scroll callback here so\n\t\t\t\t\t\t// that we can pass the context and as an argument.\n\t\t\t\t\t\t// We may be able to change this in the future if we\n\t\t\t\t\t\t// define the scroll callback in the store instead, but\n\t\t\t\t\t\t// this approach seems to tbe clearest for now.\n\t\t\t\t\t\tscrollCallback = handleScroll.bind( null, context );\n\n\t\t\t\t\t\t// We need to add a scroll event listener to the window\n\t\t\t\t\t\t// here because we are unable to otherwise access it via\n\t\t\t\t\t\t// the Interactivity API directives. If we add a native way\n\t\t\t\t\t\t// to access the window, we can remove this.\n\t\t\t\t\t\twindow.addEventListener(\n\t\t\t\t\t\t\t'scroll',\n\t\t\t\t\t\t\tscrollCallback,\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\thideLightbox: async ( { context } ) => {\n\t\t\t\t\t\tcontext.core.image.hideAnimationEnabled = true;\n\t\t\t\t\t\tif ( context.core.image.lightboxEnabled ) {\n\t\t\t\t\t\t\t// We want to wait until the close animation is completed\n\t\t\t\t\t\t\t// before allowing a user to scroll again. The duration of this\n\t\t\t\t\t\t\t// animation is defined in the styles.scss and depends on if the\n\t\t\t\t\t\t\t// animation is 'zoom' or 'fade', but in any case we should wait\n\t\t\t\t\t\t\t// a few milliseconds longer than the duration, otherwise a user\n\t\t\t\t\t\t\t// may scroll too soon and cause the animation to look sloppy.\n\t\t\t\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t\t\t\twindow.removeEventListener(\n\t\t\t\t\t\t\t\t\t'scroll',\n\t\t\t\t\t\t\t\t\tscrollCallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t// If we don't delay before changing the focus,\n\t\t\t\t\t\t\t\t// the focus ring will appear on Firefox before\n\t\t\t\t\t\t\t\t// the image has finished animating, which looks broken.\n\t\t\t\t\t\t\t\tcontext.core.image.lightboxTriggerRef.focus( {\n\t\t\t\t\t\t\t\t\tpreventScroll: true,\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}, 450 );\n\n\t\t\t\t\t\t\tcontext.core.image.lightboxEnabled = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\thandleKeydown: ( { context, actions, event } ) => {\n\t\t\t\t\t\tif ( context.core.image.lightboxEnabled ) {\n\t\t\t\t\t\t\tif ( event.key === 'Tab' || event.keyCode === 9 ) {\n\t\t\t\t\t\t\t\t// If shift + tab it change the direction\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tevent.shiftKey &&\n\t\t\t\t\t\t\t\t\twindow.document.activeElement ===\n\t\t\t\t\t\t\t\t\t\tcontext.core.image.firstFocusableElement\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\tcontext.core.image.lastFocusableElement.focus();\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t! event.shiftKey &&\n\t\t\t\t\t\t\t\t\twindow.document.activeElement ===\n\t\t\t\t\t\t\t\t\t\tcontext.core.image.lastFocusableElement\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\tcontext.core.image.firstFocusableElement.focus();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tevent.key === 'Escape' ||\n\t\t\t\t\t\t\t\tevent.keyCode === 27\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tactions.core.image.hideLightbox( {\n\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// This is fired just by lazily loaded\n\t\t\t\t\t// images on the page, not all images.\n\t\t\t\t\thandleLoad: ( { context, effects, ref } ) => {\n\t\t\t\t\t\tcontext.core.image.imageLoaded = true;\n\t\t\t\t\t\tcontext.core.image.imageCurrentSrc = ref.currentSrc;\n\t\t\t\t\t\teffects.core.image.setButtonStyles( {\n\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\tref,\n\t\t\t\t\t\t} );\n\t\t\t\t\t},\n\t\t\t\t\thandleTouchStart: () => {\n\t\t\t\t\t\tisTouching = true;\n\t\t\t\t\t},\n\t\t\t\t\thandleTouchMove: ( { context, event } ) => {\n\t\t\t\t\t\t// On mobile devices, we want to prevent triggering the\n\t\t\t\t\t\t// scroll event because otherwise the page jumps around as\n\t\t\t\t\t\t// we reset the scroll position. This also means that closing\n\t\t\t\t\t\t// the lightbox requires that a user perform a simple tap. This\n\t\t\t\t\t\t// may be changed in the future if we find a better alternative\n\t\t\t\t\t\t// to override or reset the scroll position during swipe actions.\n\t\t\t\t\t\tif ( context.core.image.lightboxEnabled ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\thandleTouchEnd: () => {\n\t\t\t\t\t\t// We need to wait a few milliseconds before resetting\n\t\t\t\t\t\t// to ensure that pinch to zoom works consistently\n\t\t\t\t\t\t// on mobile devices when the lightbox is open.\n\t\t\t\t\t\tlastTouchTime = Date.now();\n\t\t\t\t\t\tisTouching = false;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tselectors: {\n\t\t\tcore: {\n\t\t\t\timage: {\n\t\t\t\t\troleAttribute: ( { context } ) => {\n\t\t\t\t\t\treturn context.core.image.lightboxEnabled\n\t\t\t\t\t\t\t? 'dialog'\n\t\t\t\t\t\t\t: null;\n\t\t\t\t\t},\n\t\t\t\t\tariaModal: ( { context } ) => {\n\t\t\t\t\t\treturn context.core.image.lightboxEnabled\n\t\t\t\t\t\t\t? 'true'\n\t\t\t\t\t\t\t: null;\n\t\t\t\t\t},\n\t\t\t\t\tdialogLabel: ( { context } ) => {\n\t\t\t\t\t\treturn context.core.image.lightboxEnabled\n\t\t\t\t\t\t\t? context.core.image.dialogLabel\n\t\t\t\t\t\t\t: null;\n\t\t\t\t\t},\n\t\t\t\t\tlightboxObjectFit: ( { context } ) => {\n\t\t\t\t\t\tif ( context.core.image.initialized ) {\n\t\t\t\t\t\t\treturn 'cover';\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tenlargedImgSrc: ( { context } ) => {\n\t\t\t\t\t\treturn context.core.image.initialized\n\t\t\t\t\t\t\t? context.core.image.imageUploadedSrc\n\t\t\t\t\t\t\t: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\teffects: {\n\t\t\tcore: {\n\t\t\t\timage: {\n\t\t\t\t\tinitOriginImage: ( { context, ref } ) => {\n\t\t\t\t\t\tcontext.core.image.imageRef = ref;\n\t\t\t\t\t\tcontext.core.image.lightboxTriggerRef =\n\t\t\t\t\t\t\tref.parentElement.querySelector(\n\t\t\t\t\t\t\t\t'.lightbox-trigger'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tif ( ref.complete ) {\n\t\t\t\t\t\t\tcontext.core.image.imageLoaded = true;\n\t\t\t\t\t\t\tcontext.core.image.imageCurrentSrc = ref.currentSrc;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tinitLightbox: async ( { context, ref } ) => {\n\t\t\t\t\t\tif ( context.core.image.lightboxEnabled ) {\n\t\t\t\t\t\t\tconst focusableElements =\n\t\t\t\t\t\t\t\tref.querySelectorAll( focusableSelectors );\n\t\t\t\t\t\t\tcontext.core.image.firstFocusableElement =\n\t\t\t\t\t\t\t\tfocusableElements[ 0 ];\n\t\t\t\t\t\t\tcontext.core.image.lastFocusableElement =\n\t\t\t\t\t\t\t\tfocusableElements[\n\t\t\t\t\t\t\t\t\tfocusableElements.length - 1\n\t\t\t\t\t\t\t\t];\n\n\t\t\t\t\t\t\t// Move focus to the dialog when opening it.\n\t\t\t\t\t\t\tref.focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsetButtonStyles: ( { context, ref } ) => {\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tnaturalWidth,\n\t\t\t\t\t\t\tnaturalHeight,\n\t\t\t\t\t\t\toffsetWidth,\n\t\t\t\t\t\t\toffsetHeight,\n\t\t\t\t\t\t} = ref;\n\n\t\t\t\t\t\t// If the image isn't loaded yet, we can't\n\t\t\t\t\t\t// calculate where the button should be.\n\t\t\t\t\t\tif ( naturalWidth === 0 || naturalHeight === 0 ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst figure = ref.parentElement;\n\t\t\t\t\t\tconst figureWidth = ref.parentElement.clientWidth;\n\n\t\t\t\t\t\t// We need special handling for the height because\n\t\t\t\t\t\t// a caption will cause the figure to be taller than\n\t\t\t\t\t\t// the image, which means we need to account for that\n\t\t\t\t\t\t// when calculating the placement of the button in the\n\t\t\t\t\t\t// top right corner of the image.\n\t\t\t\t\t\tlet figureHeight = ref.parentElement.clientHeight;\n\t\t\t\t\t\tconst caption = figure.querySelector( 'figcaption' );\n\t\t\t\t\t\tif ( caption ) {\n\t\t\t\t\t\t\tconst captionComputedStyle =\n\t\t\t\t\t\t\t\twindow.getComputedStyle( caption );\n\t\t\t\t\t\t\tfigureHeight =\n\t\t\t\t\t\t\t\tfigureHeight -\n\t\t\t\t\t\t\t\tcaption.offsetHeight -\n\t\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginTop ) -\n\t\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginBottom );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst buttonOffsetTop = figureHeight - offsetHeight;\n\t\t\t\t\t\tconst buttonOffsetRight = figureWidth - offsetWidth;\n\n\t\t\t\t\t\t// In the case of an image with object-fit: contain, the\n\t\t\t\t\t\t// size of the <img> element can be larger than the image itself,\n\t\t\t\t\t\t// so we need to calculate where to place the button.\n\t\t\t\t\t\tif ( context.core.image.scaleAttr === 'contain' ) {\n\t\t\t\t\t\t\t// Natural ratio of the image.\n\t\t\t\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t\t\t\t// Offset ratio of the image.\n\t\t\t\t\t\t\tconst offsetRatio = offsetWidth / offsetHeight;\n\n\t\t\t\t\t\t\tif ( naturalRatio >= offsetRatio ) {\n\t\t\t\t\t\t\t\t// If it reaches the width first, keep\n\t\t\t\t\t\t\t\t// the width and compute the height.\n\t\t\t\t\t\t\t\tconst referenceHeight =\n\t\t\t\t\t\t\t\t\toffsetWidth / naturalRatio;\n\t\t\t\t\t\t\t\tcontext.core.image.imageButtonTop =\n\t\t\t\t\t\t\t\t\t( offsetHeight - referenceHeight ) / 2 +\n\t\t\t\t\t\t\t\t\tbuttonOffsetTop +\n\t\t\t\t\t\t\t\t\t10;\n\t\t\t\t\t\t\t\tcontext.core.image.imageButtonRight =\n\t\t\t\t\t\t\t\t\tbuttonOffsetRight + 10;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If it reaches the height first, keep\n\t\t\t\t\t\t\t\t// the height and compute the width.\n\t\t\t\t\t\t\t\tconst referenceWidth =\n\t\t\t\t\t\t\t\t\toffsetHeight * naturalRatio;\n\t\t\t\t\t\t\t\tcontext.core.image.imageButtonTop =\n\t\t\t\t\t\t\t\t\tbuttonOffsetTop + 10;\n\t\t\t\t\t\t\t\tcontext.core.image.imageButtonRight =\n\t\t\t\t\t\t\t\t\t( offsetWidth - referenceWidth ) / 2 +\n\t\t\t\t\t\t\t\t\tbuttonOffsetRight +\n\t\t\t\t\t\t\t\t\t10;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.core.image.imageButtonTop =\n\t\t\t\t\t\t\t\tbuttonOffsetTop + 10;\n\t\t\t\t\t\t\tcontext.core.image.imageButtonRight =\n\t\t\t\t\t\t\t\tbuttonOffsetRight + 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsetStylesOnResize: ( { state, context, ref } ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcontext.core.image.lightboxEnabled &&\n\t\t\t\t\t\t\t( state.core.image.windowWidth ||\n\t\t\t\t\t\t\t\tstate.core.image.windowHeight )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsetStyles( context, ref );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tafterLoad: ( { state } ) => {\n\t\t\twindow.addEventListener(\n\t\t\t\t'resize',\n\t\t\t\tdebounce( () => {\n\t\t\t\t\tstate.core.image.windowWidth = window.innerWidth;\n\t\t\t\t\tstate.core.image.windowHeight = window.innerHeight;\n\t\t\t\t} )\n\t\t\t);\n\t\t},\n\t}\n);\n\n/*\n * Computes styles for the lightbox and adds them to the document.\n *\n * @function\n * @param {Object} context - An Interactivity API context\n * @param {Object} event - A triggering event\n */\nfunction setStyles( context, ref ) {\n\t// The reference img element lies adjacent\n\t// to the event target button in the DOM.\n\tlet {\n\t\tnaturalWidth,\n\t\tnaturalHeight,\n\t\toffsetWidth: originalWidth,\n\t\toffsetHeight: originalHeight,\n\t} = ref;\n\tlet { x: screenPosX, y: screenPosY } = ref.getBoundingClientRect();\n\n\t// Natural ratio of the image clicked to open the lightbox.\n\tconst naturalRatio = naturalWidth / naturalHeight;\n\t// Original ratio of the image clicked to open the lightbox.\n\tlet originalRatio = originalWidth / originalHeight;\n\n\t// If it has object-fit: contain, recalculate the original sizes\n\t// and the screen position without the blank spaces.\n\tif ( context.core.image.scaleAttr === 'contain' ) {\n\t\tif ( naturalRatio > originalRatio ) {\n\t\t\tconst heightWithoutSpace = originalWidth / naturalRatio;\n\t\t\t// Recalculate screen position without the top space.\n\t\t\tscreenPosY += ( originalHeight - heightWithoutSpace ) / 2;\n\t\t\toriginalHeight = heightWithoutSpace;\n\t\t} else {\n\t\t\tconst widthWithoutSpace = originalHeight * naturalRatio;\n\t\t\t// Recalculate screen position without the left space.\n\t\t\tscreenPosX += ( originalWidth - widthWithoutSpace ) / 2;\n\t\t\toriginalWidth = widthWithoutSpace;\n\t\t}\n\t}\n\toriginalRatio = originalWidth / originalHeight;\n\n\t// Typically, we use the image's full-sized dimensions. If those\n\t// dimensions have not been set (i.e. an external image with only one size),\n\t// the image's dimensions in the lightbox are the same\n\t// as those of the image in the content.\n\tlet imgMaxWidth = parseFloat(\n\t\tcontext.core.image.targetWidth !== 'none'\n\t\t\t? context.core.image.targetWidth\n\t\t\t: naturalWidth\n\t);\n\tlet imgMaxHeight = parseFloat(\n\t\tcontext.core.image.targetHeight !== 'none'\n\t\t\t? context.core.image.targetHeight\n\t\t\t: naturalHeight\n\t);\n\n\t// Ratio of the biggest image stored in the database.\n\tlet imgRatio = imgMaxWidth / imgMaxHeight;\n\tlet containerMaxWidth = imgMaxWidth;\n\tlet containerMaxHeight = imgMaxHeight;\n\tlet containerWidth = imgMaxWidth;\n\tlet containerHeight = imgMaxHeight;\n\t// Check if the target image has a different ratio than the original one (thumbnail).\n\t// Recalculate the width and height.\n\tif ( naturalRatio.toFixed( 2 ) !== imgRatio.toFixed( 2 ) ) {\n\t\tif ( naturalRatio > imgRatio ) {\n\t\t\t// If the width is reached before the height, we keep the maxWidth\n\t\t\t// and recalculate the height.\n\t\t\t// Unless the difference between the maxHeight and the reducedHeight\n\t\t\t// is higher than the maxWidth, where we keep the reducedHeight and\n\t\t\t// recalculate the width.\n\t\t\tconst reducedHeight = imgMaxWidth / naturalRatio;\n\t\t\tif ( imgMaxHeight - reducedHeight > imgMaxWidth ) {\n\t\t\t\timgMaxHeight = reducedHeight;\n\t\t\t\timgMaxWidth = reducedHeight * naturalRatio;\n\t\t\t} else {\n\t\t\t\timgMaxHeight = imgMaxWidth / naturalRatio;\n\t\t\t}\n\t\t} else {\n\t\t\t// If the height is reached before the width, we keep the maxHeight\n\t\t\t// and recalculate the width.\n\t\t\t// Unless the difference between the maxWidth and the reducedWidth\n\t\t\t// is higher than the maxHeight, where we keep the reducedWidth and\n\t\t\t// recalculate the height.\n\t\t\tconst reducedWidth = imgMaxHeight * naturalRatio;\n\t\t\tif ( imgMaxWidth - reducedWidth > imgMaxHeight ) {\n\t\t\t\timgMaxWidth = reducedWidth;\n\t\t\t\timgMaxHeight = reducedWidth / naturalRatio;\n\t\t\t} else {\n\t\t\t\timgMaxWidth = imgMaxHeight * naturalRatio;\n\t\t\t}\n\t\t}\n\t\tcontainerWidth = imgMaxWidth;\n\t\tcontainerHeight = imgMaxHeight;\n\t\timgRatio = imgMaxWidth / imgMaxHeight;\n\n\t\t// Calculate the max size of the container.\n\t\tif ( originalRatio > imgRatio ) {\n\t\t\tcontainerMaxWidth = imgMaxWidth;\n\t\t\tcontainerMaxHeight = containerMaxWidth / originalRatio;\n\t\t} else {\n\t\t\tcontainerMaxHeight = imgMaxHeight;\n\t\t\tcontainerMaxWidth = containerMaxHeight * originalRatio;\n\t\t}\n\t}\n\n\t// If the image has been pixelated on purpose, keep that size.\n\tif ( originalWidth > containerWidth || originalHeight > containerHeight ) {\n\t\tcontainerWidth = originalWidth;\n\t\tcontainerHeight = originalHeight;\n\t}\n\n\t// Calculate the final lightbox image size and the\n\t// scale factor. MaxWidth is either the window container\n\t// (accounting for padding) or the image resolution.\n\tlet horizontalPadding = 0;\n\tif ( window.innerWidth > 480 ) {\n\t\thorizontalPadding = 80;\n\t} else if ( window.innerWidth > 1920 ) {\n\t\thorizontalPadding = 160;\n\t}\n\tconst verticalPadding = 80;\n\n\tconst targetMaxWidth = Math.min(\n\t\twindow.innerWidth - horizontalPadding,\n\t\tcontainerWidth\n\t);\n\tconst targetMaxHeight = Math.min(\n\t\twindow.innerHeight - verticalPadding,\n\t\tcontainerHeight\n\t);\n\tconst targetContainerRatio = targetMaxWidth / targetMaxHeight;\n\n\tif ( originalRatio > targetContainerRatio ) {\n\t\t// If targetMaxWidth is reached before targetMaxHeight\n\t\tcontainerWidth = targetMaxWidth;\n\t\tcontainerHeight = containerWidth / originalRatio;\n\t} else {\n\t\t// If targetMaxHeight is reached before targetMaxWidth\n\t\tcontainerHeight = targetMaxHeight;\n\t\tcontainerWidth = containerHeight * originalRatio;\n\t}\n\n\tconst containerScale = originalWidth / containerWidth;\n\tconst lightboxImgWidth =\n\t\timgMaxWidth * ( containerWidth / containerMaxWidth );\n\tconst lightboxImgHeight =\n\t\timgMaxHeight * ( containerHeight / containerMaxHeight );\n\n\t// Add the CSS variables needed.\n\tlet styleTag = document.getElementById( 'wp-lightbox-styles' );\n\tif ( ! styleTag ) {\n\t\tstyleTag = document.createElement( 'style' );\n\t\tstyleTag.id = 'wp-lightbox-styles';\n\t\tdocument.head.appendChild( styleTag );\n\t}\n\n\t// As of this writing, using the calculations above will render the lightbox\n\t// with a small, erroneous whitespace on the left side of the image in iOS Safari,\n\t// perhaps due to an inconsistency in how browsers handle absolute positioning and CSS\n\t// transformation. In any case, adding 1 pixel to the container width and height solves\n\t// the problem, though this can be removed if the issue is fixed in the future.\n\tstyleTag.innerHTML = `\n\t\t:root {\n\t\t\t--wp--lightbox-initial-top-position: ${ screenPosY }px;\n\t\t\t--wp--lightbox-initial-left-position: ${ screenPosX }px;\n\t\t\t--wp--lightbox-container-width: ${ containerWidth + 1 }px;\n\t\t\t--wp--lightbox-container-height: ${ containerHeight + 1 }px;\n\t\t\t--wp--lightbox-image-width: ${ lightboxImgWidth }px;\n\t\t\t--wp--lightbox-image-height: ${ lightboxImgHeight }px;\n\t\t\t--wp--lightbox-scale: ${ containerScale };\n\t\t}\n\t`;\n}\n\n/*\n * Debounces a function call.\n *\n * @function\n * @param {Function} func - A function to be called\n * @param {number} wait - The time to wait before calling the function\n */\nfunction debounce( func, wait = 50 ) {\n\tlet timeout;\n\treturn () => {\n\t\tconst later = () => {\n\t\t\ttimeout = null;\n\t\t\tfunc();\n\t\t};\n\t\tclearTimeout( timeout );\n\t\ttimeout = setTimeout( later, wait );\n\t};\n}\n"],"names":["window","focusableSelectors","scrollCallback","isTouching","lastTouchTime","handleScroll","context","Date","now","scrollTo","core","image","scrollLeftReset","scrollTopReset","setStyles","ref","naturalWidth","naturalHeight","offsetWidth","originalWidth","offsetHeight","originalHeight","x","screenPosX","y","screenPosY","getBoundingClientRect","naturalRatio","originalRatio","scaleAttr","heightWithoutSpace","widthWithoutSpace","imgMaxWidth","parseFloat","targetWidth","imgMaxHeight","targetHeight","imgRatio","containerMaxWidth","containerMaxHeight","containerWidth","containerHeight","toFixed","reducedHeight","reducedWidth","horizontalPadding","innerWidth","targetMaxWidth","Math","min","targetMaxHeight","innerHeight","containerScale","lightboxImgWidth","lightboxImgHeight","styleTag","document","getElementById","createElement","id","head","appendChild","innerHTML","store","state","windowWidth","windowHeight","actions","showLightbox","event","imageLoaded","initialized","lastFocusedElement","activeElement","scrollDelta","pointerType","lightboxEnabled","imageRef","pageYOffset","documentElement","scrollTop","pageXOffset","scrollLeft","bind","addEventListener","hideLightbox","async","hideAnimationEnabled","setTimeout","removeEventListener","lightboxTriggerRef","focus","preventScroll","handleKeydown","key","keyCode","shiftKey","firstFocusableElement","preventDefault","lastFocusableElement","handleLoad","effects","imageCurrentSrc","currentSrc","setButtonStyles","handleTouchStart","handleTouchMove","handleTouchEnd","selectors","roleAttribute","ariaModal","dialogLabel","lightboxObjectFit","enlargedImgSrc","imageUploadedSrc","initOriginImage","parentElement","querySelector","complete","initLightbox","focusableElements","querySelectorAll","length","figure","figureWidth","clientWidth","figureHeight","clientHeight","caption","captionComputedStyle","getComputedStyle","marginTop","marginBottom","buttonOffsetTop","buttonOffsetRight","referenceHeight","imageButtonTop","imageButtonRight","referenceWidth","setStylesOnResize","afterLoad","func","wait","timeout","clearTimeout","later","debounce"],"sourceRoot":""}